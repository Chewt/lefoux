#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include "uci.h"
#include "board.h"
#include "engine.h"
#include "timer.h"
#include "bitHelpers.h"

/*******************************************************************************
 *
 * Command functions
 *
 * These functions must all follow the same pattern and function
 * signature. They must return an int, and take two arguments: a Board pointer
 * and a char pointer. The Board pointer is the current boardstate, and the
 * char pointer is the entire command that is being processed. The name of the
 * function corresponds to the command name.
 *
 ******************************************************************************/

int isready(Board* board, char* command)
{
    char s[][] = {
        "readyok\n"
    };
    for (int i=0; i<1; i++) {
        printf("%s", s[i]);
    }
    return 1;
}

int uci(Board* board, char* command)
{
    char s[][] = {
        "id name Lefoux\n",
        "id author Hayden Johnson and Zachary Gorman\n",
        "uciok\n"
    };
    for (int i=0; i<1; i++) {
        printf("%s", s[i]);
    }
    return 1;
}

/*
 * @param movestr string to be parsed, should be in Long Algebraic Notation
 * @return move generated by movestr. Not an undo move
 */
Move parseMove(char *movestr)
{
    Move m = {0};
    if (strlen(movestr) < 4) return m;
    // Set source
    m = ((movestr[0] - 'a') + (movestr[1] - '1')*8) << 13;
    // Set destination
    m |= ((movestr[2] - 'a') + (movestr[3] - '1')*8) << 7;
    // Find the piece type
    int piece_type;
    int color;
    for (color = _WHITE; color <= _BLACK; color++)
        for (piece_type=PAWN; piece_type<=KING; piece_type++)
            if (mgetsrcbb(m) & board->pieces[piece_type + color]) break;
    m |= (piece_type << 4) | (color);
    // Check for promotions
    switch (movestr[4])
    {
        case 'n': m |= KNIGHT << 1; break;
        case 'b': m |= BISHOP << 1; break;
        case 'r': m |= ROOK   << 1; break;
        case 'q': m |= QUEEN  << 1; break;
    }
    return m;
}

int position(Board* board, char* command)
{
    char *saveptr;
    /* token should be "position" */
    char *token = strtok_r(command, " \n", &saveptr);
    /* How to read the next parameter */
    token = strtok_r(NULL, " \n", &saveptr);
    if (token && !strcmp(token, "fen"))
    {
        int charsRead = loadFen(board, saveptr);
        if (!charsRead)
        {
            fprintf(stderr, "fen formatted incorrectly, likely not enough "
                            "fields: %s\n", saveptr);
            return 0;
        }
        saveptr += charsRead;
    }
    else if (token && !strcmp(token, "startpos"))
    {
        Board b = getDefaultBoard();
        memcpy(board, &b, sizeof(Board));
    } else if (token) {
        fprintf(stderr, "Unknown postion type, must be of [fen | startpos]: "
                        "%s\n", token);
        return 1;
    } else {
        fprintf(stderr, "No position type given. Use: position [fen | startpos]"
                        " moves ....\n");
        return 1;
    }
    /* Process moves after position is set */
    /* Token should be "moves" */
    token = strtok_r(NULL, " \n", &saveptr);
    while ( token = strtok_r(NULL, " \n", &saveptr) )
    {
        Move m = parseMove(token);
        if (!m) continue;
        m = boardMove(board, m);
    }
    return 1;
}

int go(Board* board, char* command)
{
    char *saveptr;
    /* token should be "go" */
    char *token = strtok_r(command, " \n", &saveptr);
    /* parameters to tweak with subcommands */
    Move moves[MAX_MOVES_PER_POSITION];
    int numMoves = 0;
    int depth = 5;
    /* go subcommand */
    while (token = strtok_r(NULL, " \n", &saveptr))
    {
        if (!strcmp(token, "searchmoves"))
        {
            while ( token = strtok_r(NULL, " \n", &saveptr) )
            {
                moves[numMoves] = parseMove(token);
                if (!moves[numMoves]) break;
                numMoves++;
            }
        }
        if (!strcmp(token, "wtime"))
        {
            /* token is number of ms left on the clock for white */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "btime"))
        {
            /* token is number of ms left on the clock for black */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "winc"))
        {
            /* token is white's increment per move in ms if x > 0 */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "binc"))
        {
            /* token is black's increment per move in ms if x > 0 */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "movestogo"))
        {
            /* token is the number of moves until next time control */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "depth"))
        {
            /* token is the number of plies to search */
            token = strtok_r(NULL, " \n", &saveptr);
            depth = atoi(token);
        }
        if (!strcmp(token, "nodes"))
        {
            /* token is the number of nodes to search */
            token = strtok_r(NULL, " \n", &saveptr);
            depth = atoi(token);
            // An estimate conversion from number of nodes to ply
            depth = bitScanReverse(depth);
        }
        if (!strcmp(token, "mate"))
        {
            /* token is the number of moves to find a mate */
            token = strtok_r(NULL, " \n", &saveptr);
            depth = atoi(token);
        }
        if (!strcmp(token, "movetime"))
        {
            /* token is the amount of time to search in ms */
            token = strtok_r(NULL, " \n", &saveptr);
        }
        if (!strcmp(token, "infinite"))
        {
            /* Search until the "stop" command */
        }
    }
    Move bestMove = 0;
    Board tmpBoard;
    for (int i=0; i<numMoves; i++)
    {
        memcpy(&tmpBoard, board, sizeof(Board));
        boardMove(&tmpBoard, moves[i]);
        moves[i] = msetweight(moves[i],
                   mgetweight(find_best_move(board, depth)));
        if (mgetweight(moves[i]) > mgetweight(bestMove) ||
                (mgetweight(moves[i]) == mgetweight(bestMove) && rand() & 1))
            bestMove = moves[i];
    }
    /* Deliver bestMove */
    printf("bestmove %c%c%c%c", (mgetsrc(bestMove) % 8) + 'a',
                                (mgetsrc(bestMove) / 8) + '1',
                                (mgetdst(bestMove) % 8) + 'a',
                                (mgetdst(bestMove) / 8) + '1');
    switch (mgetprom(bestMove))
    {
        case KNIGHT: printf("n\n"); break;
        case BISHOP: printf("b\n"); break;
        case ROOK  : printf("r\n"); break;
        case QUEEN : printf("q\n"); break;
        default    : printf("\n");
    }

    return 1;
}

int debug(Board* board, char* command)
{
    char* s = "readyok\n";
    if (write(1, s, strlen(s)) == -1)
        fprintf(stderr, "WHAT?!? there was an error\n");
    return 1;
}

int setoption(Board* board, char* command)
{
    char* s = "readyok\n";
    if (write(1, s, strlen(s)) == -1)
        fprintf(stderr, "WHAT?!? there was an error\n");
    return 1;
}

int ucinewgame(Board* board, char* command)
{
    char s[][] = {
        "readyok\n"
    };
    for (int i=0; i<1; i++) {
        printf("%s", s[i]);
    }
    return 1;
}

int stop(Board* board, char* command)
{
    char* s = "readyok\n";
    if (write(1, s, strlen(s)) == -1)
        fprintf(stderr, "WHAT?!? there was an error\n");
    return 1;
}

int ponderhit(Board* board, char* command)
{
    char* s = "readyok\n";
    if (write(1, s, strlen(s)) == -1)
        fprintf(stderr, "WHAT?!? there was an error\n");
    return 1;
}

inline int uciquit(Board *board, char *command) { return 0; }

/* Non-uci commands */

int printboard(Board* board, char* command)
{
    printBoard(board);
    return 1;
}

int perft(Board* board, char* command)
{
    char *saveptr;
    /* token should be "perft" */
    char *token = strtok_r(command, " \n", &saveptr);
    /* Get depth */
    if (!(token = strtok_r(NULL, " \n", &saveptr))) {
        fprintf(stderr, "No depth given. Use: perft <depth>\n");
        return 1;
    }

    int depth = atoi(token);
    if (!depth) {
        fprintf(stderr, "Either depth is 0 or depth isn't a number: %s\n",
                token);
        return 1;
    } else if (depth < 0) {
        fprintf(stderr, "Depth is less than 0: %d\n", depth);
        return 1;
    }

    Timer t;
    PerftInfo p = {0};
    StartTimer(&t);
    perftRun(board, &p, depth);
    StopTimer(&t);
    printf("Took %.6f seconds\n", t.time_taken);
    printPerft(p);
    return 1;
}

int fen(Board* board, char* command)
{
    printFen(board);
    return 1;
}

/* This struct holds all of the commands that are accepted by lefoux. The format
 * for this struct is a keyword to match, that is the first word in the command,
 * and a function pointer to be called if the command matches the keyword. The
 * last entry is filled with zeros to mark the end of the array.
 */
Command allcommands[] = {
    // Uci commands
    {"isready", isready},
    {"uci", uci},
    {"position", position},
    {"go", go},
    {"debug", debug},
    {"setoption", setoption},
    {"ucinewgame", ucinewgame},
    {"stop", stop},
    {"ponderhit", ponderhit},
    {"register", isready},
    {"ucinewgame", isready},
    {"quit", uciquit},
    // Non-uci commands
    {"printboard", printboard},
    {"perft", perft},
    {"fen", fen},
    {{0},0} // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53119
};

int ProcessCommand(Board* board, char* command)
{
    char command_copy[COMMAND_LIMIT];
    memcpy(command_copy, command, COMMAND_LIMIT);
    char* saveptr;
    char* token = strtok_r(command, "\n", &saveptr);
    token = strtok_r(command, " ", &saveptr);
    Command* c;
    for (c = allcommands; c->match[0] != 0; c++)
    {
        if (!strcmp(c->match, token))
            return c->func(board, command_copy);
    }
    fprintf(stderr, "Unknown command: %s\n", token);
    return 1;
}
